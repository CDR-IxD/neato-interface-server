<!DOCTYPE html>
<html>
<head>
  <style>
    #camera-frame {
      position: absolute;
      margin: 0;
      padding: 0;
      top: 0;
      left: 0;
      height: 100%;
      width: 100%;
    }
    
    #root, #drag-view {
      position: absolute;
      margin: 0;
      padding: 0;
      top: 0;
      left: 0;
      height: 100%;
      width: 100%;
    }
        
    .buttons {
      z-index: 1000;
      width: 250px;
      text-align: center;
      position: absolute;
      top: 10;
      left: 50%;
      margin-left: -125px;
      background: white;
      opacity: 0.5;
      padding: 0;
      border-radius: 0 0 20px 20px;
    }
    
    .buttons button {
      width: 60px;
      height: 30px;
      
      background: blue;
      border: 0;
      border-radius: 8px;
      opacity: 1.0;
      color: white;
      margin: 2px;
    }
    .buttons button:active, .buttons button.active {
      background: #abcdef;
    }
    
    svg text::selection {
      background: none;
    }
        
    iframe {
      border: 0;
    }
  </style>
  <title>Path control</title>
  
  <script src="react.development.js"></script>
  <script src="react-dom.development.js"></script>
  <script src="babel.min.js"></script>
  <script src="jquery-3.2.1.js"></script>
  </head>
<body>
  <iframe id="camera-frame"></iframe>
  <script type="text/javascript">
    var camera = document.getElementById('camera-frame');
    camera.src = "/view-stream.html"
  </script>
  <div id="root"><!-- react root --></div>
  
  <script type="text/babel">
    var restrictedFiducialId = window.location.hash.startsWith('#') ? Number(window.location.hash.substr(1)) : null;
    var socket;
    
    function connectNewSocket() {
      socket = new WebSocket("ws://"+document.location.host+"/web-controller");
      socket.onmessage = function(event) {
        let data = JSON.parse(event.data);
        data.bots.forEach(handleUpdate);
      }
      socket.onopen = function(event) {
        socket.onclose = function() {
          setTimeout(connectNewSocket, 500);
        }
      }
    }
    $(connectNewSocket);
    
    function pathId() {
      return ""+Math.round(Math.random()*1e7);
    }
    
    function sendPath(fiducialKey, path) {
      console.log("requesting path", fiducialKey, path);
      let pid = pathId();
      socket.send(JSON.stringify({
        action: "requestPath",
        bot: fiducialKey,
        pathId: pid,
        path: path
      }));
    }
    
    function sendForce(fiducialKey, forcedForward, forcedTurn) {
      console.log("requesting force", fiducialKey, forcedForward, forcedTurn);
      socket.send(JSON.stringify({
        action: "requestForced",
        bot: fiducialKey,
        forward: forcedForward,
        turn: forcedTurn
      }));
    }

    var theViewer;
    function handleUpdate(update) {
      if (theViewer) {
        theViewer.handleUpdate(update);
      }
    }
    
    function centerOf(pts) {
      return pts.reduce((p, c, _, {length: n}) => ({x: p.x+c.x/n, y: p.y+c.y/n}), {x: 0, y: 0}); // average of points
    }
    
    function distance(p1, p2) {
      return p1 == null || p2 == null ? Number.POSITIVE_INFINITY : Math.sqrt(Math.pow(p2.x-p1.x, 2) + Math.pow(p2.y-p1.y, 2));
    }
    
    function scale(pt, scale) {
      return pt ? {x: scale*pt.x, y: scale*pt.y} : {x: 0, y: 0};
    }

    class ChairBot extends React.Component {
      location() {
        return this.props.status.location.map(pt => scale(pt, 100));
      }
      
      centerPt() {
        return centerOf(this.location());
      }
      
      chair() {
        let loc = this.location();
        // console.log("path from", loc);
        let [p1, p2, p3, p4] = loc;
        let cpt = centerOf(loc);
        let dir = centerOf([p1, p2]);
        
        return `M${p1.x},${p1.y}L${p2.x},${p2.y}L${p3.x},${p3.y}L${p4.x},${p4.y}Z M${cpt.x},${cpt.y}L${dir.x},${dir.y}`;
      }
      
      path() {
        let points = (this.props.status.path || []).map(pt => scale(pt, 100));
        if (points.length > 0) {
          return "M" + points.map(({x, y}) => `${x},${y}`).join("L")
        } else {
          return "";
        }
      }
      
      render() {
        let cpt = this.centerPt();
        return <g>
          <path d={this.chair()} strokeWidth="1" stroke={this.props.isDraggable ? "#0a0" : "#000"} fill="none" strokeLinejoin="round"/>
          {this.props.status.path ? <path d={this.path()} strokeWidth="1" stroke="#a00" fill="none" /> : ""}
          <circle cx={cpt.x} cy={cpt.y} r="3" fill="#fff" opacity="0.5"/>
          <text x={cpt.x-1.5} y={cpt.y+1.5} fontFamily="Verdana" fontSize="5" fill="#000">{this.props.status.id}</text>
        </g>
      }
    }
    
    class PathView extends React.Component {
      path() {
        let loc = this.props.path.map(pt => scale(pt, 100));
        return `M${loc.map(pt => `${pt.x},${pt.y}`).join('L')}`;
      }
      
      render() {
        return <path d={this.path()} strokeWidth="1" fill="none" />
      }
    }

    class DragViewApp extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          states: {},
          restrictedFiducialId: restrictedFiducialId,
          forcedForward: 0,
          forcedTurn: 0
        }
        
        this.forcedTimer = setInterval(() => this.checkAndSendForce(), 250);
      }
      
      fiducialCenter(key) {
        let loc = this.state.states[key];
        return loc && centerOf(loc.location);
      }
            
      mousePosition(event) {
        let bounds = ReactDOM.findDOMNode(this.svg).getBoundingClientRect();
        return {x: event.pageX/bounds.width, y: event.pageY/bounds.height}
      }
      
      nearestFiducial(point) {
        let keys = Object.keys(this.state.states)
        if (this.state.restrictedFiducialId !== null) {
          keys = keys.filter(k => k == this.state.restrictedFiducialId);
        }
        return keys.reduce((p, k) => {
          if (distance(this.fiducialCenter(k), point) < distance(this.fiducialCenter(p), point)) {
            return k;
          } else {
            return p;
          }
        }, null);
      }
      
      isSvgEvent(event) {
        return event.target === this.svg;
      }
      
      mouseDown(event) {
        // if (! this.isSvgEvent(event)) { return; }
        this.dragging = true;
        let point = this.mousePosition(event);
        let candidate = this.nearestFiducial(point);
        console.log("mouse down with candidate", candidate);
        this.setState({
          candidate: candidate,
          pathInProgress: [this.fiducialCenter(candidate), point]
        });
      }
      
      mouseUp(event) {
        // if (! this.isSvgEvent(event)) { return; }
        if (! this.dragging) { return; }
        this.dragging = false;
        let point = this.mousePosition(event);
        this.setState(state => ({
          pathInProgress: state.pathInProgress.concat([point])
        }), () => this.processDrag());
      }
      
      mouseMove(event) {
        // if (! this.isSvgEvent(event)) { return; }
        if (! this.dragging) { return; }
        let point = this.mousePosition(event);
        this.setState(state => ({
          pathInProgress: state.pathInProgress.concat([point])
        }));
      }
      
      mouseLeave(event) {
        this.mouseUp(event);
      }
      
      keyDown(event) {
        // console.log("DOWN", event.key);
        this.handleKeyDown(event.key);
      }
      
      keyUp(event) {
        // console.log("UP", event.key);
        this.handleKeyUp(event.key);
      }
      
      handleKeyDown(key) {
        if (key >= '0' && key <= '9') {
          this.setState({
            restrictedFiducialId: Number(key)
          });
        } else if (key == '-') {
          this.setState({
            restrictedFiducialId: null
          });
        } else {
          let send = false;
          this.setState(state => {
          switch(key) {
            case 'w':
              console.log('down w');
              send = true;
              return {
                forcedForward: 1 // (state.forcedForward || 0) + 1
              };
                    
            case 'a':
              console.log('down a');
              send = true;
              return {
                forcedTurn: -1 // state.forcedTurn - 1
              };
          
            case 's':
              console.log('down s');
              send = true;
              return {
                forcedForward: -1 // (state.forcedForward > 0 ? 0 : (state.forcedForward || 0) - 1)
              };
            
            case 'd':
              console.log('down d');
              send = true;
              return {
                forcedTurn: 1 //state.forcedTurn + 1
              };
            
            case ' ':
              console.log('down <space>');
              send = true;
              return {
                forcedForward: 0,
                forcedTurn: 0
              };
            }
          }, () => send && this.sendForce());
        }
      }
      
      handleKeyUp(key) {
        let send = false;
        this.setState(state => {
          switch(key) {
          case 'w':
            console.log('up w');
            send = true;
            return {
              forcedForward: 0
            }
          case 'a':
            console.log('up a');
            send = true;
            return {
              forcedTurn: 0
            }
          case 's':
            console.log('up s');
            send = true;
            return {
              forcedForward: 0
            }
          case 'd':
            console.log('up d');
            send = true;
            return {
              forcedTurn: 0
            }
          }
        }, () => send && this.sendForce());
      }
      
      checkAndSendForce() {
        if (this.state.forcedTurn || this.state.forcedForward) {
          this.sendForce();
        }
      }
      
      sendForce() {
        sendForce(this.state.restrictedFiducialId, this.state.forcedForward, this.state.forcedTurn);
      }
      
      processDrag() {        
        sendPath(this.state.candidate, this.state.pathInProgress);
        this.setState({
          candidate: null,
          pathInProgress: null
        });
      }
      
      render() {
        return <div tabIndex="0"
            onKeyDown={this.keyDown.bind(this)}
            onKeyUp={this.keyUp.bind(this)} >
          <div className="buttons">
            <p>
              Drag on the screen, starting from a chairbot, to request a path. <br /><br /><strong>{this.state.restrictedFiducialId ? `You control chairbot #${this.state.restrictedFiducialId}.` : "You can control any chairbot."}</strong>
              {this.state.restrictedFiducialId ? <span>
                <br />
                Or use these keys:<br />
                <button ref={(w) => this.arrowUp = w}
                        className={this.state.forcedForward > 0 ? "active" : ""}
                        onMouseDown={() => this.handleKeyDown('w')}
                        onMouseUp={() => this.handleKeyUp('w')}
                        onMouseLeave={() => this.handleKeyUp('w')}>w</button><br />
                <button ref={(a) => this.arrowLeft = a} 
                        className={this.state.forcedTurn < 0 ? "active" : ""}
                        onMouseDown={() => this.handleKeyDown('a')}
                        onMouseUp={() => this.handleKeyUp('a')}
                        onMouseLeave={() => this.handleKeyUp('a')}>a</button>
                <button ref={(s) => this.arrowDown = s} 
                        className={this.state.forcedForward < 0 ? "active" : ""}
                        onMouseDown={() => this.handleKeyDown('s')}
                        onMouseUp={() => this.handleKeyUp('s')}
                        onMouseLeave={() => this.handleKeyUp('s')}>s</button>
                <button ref={(d) => this.arrowRight = d} 
                        className={this.state.forcedTurn > 0 ? "active" : ""}
                        onMouseDown={() => this.handleKeyDown('d')}
                        onMouseUp={() => this.handleKeyUp('d')}
                        onMouseLeave={() => this.handleKeyUp('d')}>d</button><br />
                <button ref={(stop) => this.stopButton = stop}
                        onMouseDown={() => this.handleKeyDown(' ')}
                        onMouseUp={() => this.handleKeyUp(' ')}
                        onMouseLeave={() => this.handleKeyUp(' ')}>stop</button>
              </span> : ''}
            </p>
          </div>
          <svg 
            id="drag-view" 
            viewBox="0 0 100 100" 
            preserveAspectRatio="none"
            ref={(ref) => this.svg = ref}
            onMouseDown={this.mouseDown.bind(this)}
            onMouseUp={this.mouseUp.bind(this)}
            onMouseMove={this.mouseMove.bind(this)}
            onMouseLeave={this.mouseLeave.bind(this)} >
              {Object.keys(this.state.states).map(key =>
                <ChairBot status={this.state.states[key]} highlight={key == this.state.candidate} key={`chair-${key}`} isDraggable={this.state.restrictedFiducialId === null || key == this.state.restrictedFiducialId /* == intentional to allow type conversion */} />
              )}
              {this.state.pathInProgress ? <g stroke="#0a0"><PathView path={this.state.pathInProgress} /></g> : ''}
          </svg>
        </div>
      }
      
      componentDidMount() {
        // console.log("Drag View App mounted!");
        theViewer = this;
      }
      
      handleUpdate(status) {
        console.log("update!", status);
        let newStates = {};
        newStates[status.id] = status;
        this.setState((state) => ({
          states: Object.assign({}, state.states, newStates),
        }));
      }
    }
    $(function() {
      ReactDOM.render(<DragViewApp />, document.getElementById('root'));
    });
  </script>
</body>
