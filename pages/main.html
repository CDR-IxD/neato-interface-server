<!DOCTYPE html>
<html>
<head>
  <style>
    #camera-frame {
      position: absolute;
      margin: 0;
      padding: 0;
      top: 0;
      left: 0;
      height: 100%;
      width: 100%;
    }
    
    #root, #drag-view {
      position: absolute;
      margin: 0;
      padding: 0;
      top: 0;
      left: 0;
      height: 100%;
      width: 100%;
    }
        
    .buttons {
      z-index: 1000;
      width: 250px;
      text-align: center;
      position: absolute;
      top: 10;
      left: 50%;
      margin-left: -125px;
      background: white;
      opacity: 0.5;
      padding: 0;
      border-radius: 0 0 20px 20px;
    }
    
    .buttons.double {
      width: 500px;
      margin-left: -250px;
    }
    
    .double .info {
      width: 230px;
      display: inline-block;
      vertical-align: top;
    }
    
    .buttons button {
      width: 60px;
      height: 30px;
      
      background: blue;
      border: 0;
      border-radius: 8px;
      opacity: 1.0;
      color: white;
      margin: 2px;
    }
    .buttons button:active, .buttons button.active {
      background: #abcdef;
    }
    
    svg text::selection {
      background: none;
    }
        
    iframe {
      border: 0;
    }
    
    .double .keyGroup {
      display: inline-block;
      width: 230px;
      vertical-align: top;
    }
  </style>
  <title>Path control</title>
  
  <script src="react.development.js"></script>
  <script src="react-dom.development.js"></script>
  <script src="babel.min.js"></script>
  <script src="jquery-3.2.1.js"></script>
  </head>
<body>
  <iframe id="camera-frame"></iframe>
  <script type="text/javascript">
    var camera = document.getElementById('camera-frame');
    camera.src = "/view-stream.html"
  </script>
  <div id="root"><!-- react root --></div>
  
  <script type="text/babel">
    var restrictedFiducialId = window.location.hash.startsWith('#') ? Number(window.location.hash.substr(1)) : null;
    var socket;
    
    function connectNewSocket() {
      socket = new WebSocket("ws://"+document.location.host+"/web-controller");
      socket.onmessage = function(event) {
        let data = JSON.parse(event.data);
        data.bots.forEach(handleUpdate);
      }
      socket.onopen = function(event) {
        socket.onclose = function() {
          setTimeout(connectNewSocket, 500);
        }
      }
    }
    $(connectNewSocket);
    
    function pathId() {
      return ""+Math.round(Math.random()*1e7);
    }
    
    function sendPath(fiducialKey, path, topSpeed, accel) {
      console.log("requesting path", fiducialKey, path);
      let pid = pathId();
      socket.send(JSON.stringify({
        action: "requestPath",
        bot: fiducialKey,
        pathId: pid,
        path: path,
        topSpeed: topSpeed,
        accel: accel
      }));
    }
    
    function sendForce(fiducialKey, forcedForward, forcedTurn, topSpeed, accel) {
      console.log("requesting force", fiducialKey, forcedForward, forcedTurn);
      socket.send(JSON.stringify({
        action: "requestForced",
        bot: fiducialKey,
        forward: forcedForward,
        turn: forcedTurn,
        topSpeed: topSpeed,
        accel: accel
      }));
    }
    
    function sendSpeed(fiducialKey, topSpeed, accel) {
      console.log("updating speed", fiducialKey, topSpeed, accel);
      socket.send(JSON.stringify({
        action: "requestSpeed",
        bot: fiducialKey,
        topSpeed: topSpeed,
        accel: accel
      }));
    }
    
    var theViewer;
    function handleUpdate(update) {
      if (theViewer) {
        theViewer.handleUpdate(update);
      }
    }
    
    function centerOf(pts) {
      return pts.reduce((p, c, _, {length: n}) => ({x: p.x+c.x/n, y: p.y+c.y/n}), {x: 0, y: 0}); // average of points
    }
    
    function distance(p1, p2) {
      return p1 == null || p2 == null ? Number.POSITIVE_INFINITY : Math.sqrt(Math.pow(p2.x-p1.x, 2) + Math.pow(p2.y-p1.y, 2));
    }
    
    function scale(pt, scale) {
      return pt ? {x: scale*pt.x, y: scale*pt.y} : {x: 0, y: 0};
    }

    class ChairBot extends React.Component {
      location() {
        return this.props.status.location.map(pt => scale(pt, 100));
      }
      
      centerPt() {
        return centerOf(this.location());
      }
      
      chair() {
        let loc = this.location();
        // console.log("path from", loc);
        let [p1, p2, p3, p4] = loc;
        let cpt = centerOf(loc);
        let dir = centerOf([p1, p2]);
        
        return `M${p1.x},${p1.y}L${p2.x},${p2.y}L${p3.x},${p3.y}L${p4.x},${p4.y}Z M${cpt.x},${cpt.y}L${dir.x},${dir.y}`;
      }
      
      path() {
        let points = (this.props.status.path || []).map(pt => scale(pt, 100));
        if (points.length > 0) {
          return "M" + points.map(({x, y}) => `${x},${y}`).join("L")
        } else {
          return "";
        }
      }
      
      render() {
        let cpt = this.centerPt();
        return <g>
          <path d={this.chair()} strokeWidth="1" stroke={this.props.isDraggable ? "#0a0" : "#000"} fill="none" strokeLinejoin="round"/>
          {this.props.status.path ? <path d={this.path()} strokeWidth="1" stroke="#a00" fill="none" /> : ""}
          <circle cx={cpt.x} cy={cpt.y} r="3" fill="#fff" opacity="0.5"/>
          <text x={cpt.x-1.5} y={cpt.y+1.5} fontFamily="Verdana" fontSize="5" fill="#000">{this.props.status.id}</text>
        </g>
      }
    }
    
    class PathView extends React.Component {
      path() {
        let loc = this.props.path.map(pt => scale(pt, 100));
        return `M${loc.map(pt => `${pt.x},${pt.y}`).join('L')}`;
      }
      
      render() {
        return <path d={this.path()} strokeWidth="1" fill="none" />
      }
    }

    class KeyButton extends React.Component {
      render() {
        let props = this.props;
        let handler = props.handler;
        let key = this.props.keyChar;
        let text = this.props.text || key;
        return <button
                className={props.pressed ? "active" : ""}
                onMouseDown={() => handler.handleKeyDown(key)}
                onTouchStart={(event) => { handler.handleKeyDown(key); event.preventDefault(); }}
                onMouseUp={() => handler.handleKeyUp(key)}
                onMouseLeave={() => handler.handleKeyUp(key)}
                onTouchCancel={() => handler.handleKeyUp(key)}
                onTouchEnd={() => handler.handleKeyUp(key)} >
            {text}
          </button>
        
      }
    }

    class DragViewApp extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          states: {},
          restrictedFiducialId: restrictedFiducialId,
          forcedForward: 0,
          forcedTurn: 0,
          topSpeed: 50,
          accel: 50
        }
        
        this.forcedTimer = setInterval(() => this.checkAndSendForce(), 250);
      }
      
      fiducialCenter(key) {
        let loc = this.state.states[key];
        return loc && centerOf(loc.location);
      }

      mousePosition(event) {
        if (! ('pageX' in event) && ! (event.nativeEvent.touches.length > 0)) {
          return null;
        }
        let bounds = ReactDOM.findDOMNode(this.svg).getBoundingClientRect();
        return {
          x: ('pageX' in event ? event.pageX : event.nativeEvent.touches[0].pageX) / bounds.width, 
          y: ('pageY' in event ? event.pageY : event.nativeEvent.touches[0].pageY) / bounds.height
        }
      }
      
      nearestFiducial(point) {
        let keys = Object.keys(this.state.states)
        if (this.state.restrictedFiducialId !== null) {
          keys = keys.filter(k => k == this.state.restrictedFiducialId);
        }
        return keys.reduce((p, k) => {
          if (distance(this.fiducialCenter(k), point) < distance(this.fiducialCenter(p), point)) {
            return k;
          } else {
            return p;
          }
        }, null);
      }
      
      isSvgEvent(event) {
        return event.target === this.svg;
      }
      
      mouseDown(event) {
        // if (! this.isSvgEvent(event)) { return; }
        this.dragging = true;
        let point = this.mousePosition(event);
        let candidate = this.nearestFiducial(point);
        console.log("mouse down with candidate", candidate);
        this.setState({
          candidate: candidate,
          pathInProgress: [this.fiducialCenter(candidate), point]
        });
      }
      
      touchStart(event) {
        this.mouseDown(event);
        event.preventDefault();
      }
      
      mouseMove(event) {
        // if (! this.isSvgEvent(event)) { return; }
        if (! this.dragging) { return; }
        let point = this.mousePosition(event);
        this.setState(state => ({
          pathInProgress: state.pathInProgress.concat([point])
        }));
      }
      
      touchMove(event) {
        this.mouseMove(event);
        event.preventDefault();
      }

      mouseUp(event) {
        // if (! this.isSvgEvent(event)) { return; }
        if (! this.dragging) { return; }
        this.dragging = false;
        let point = this.mousePosition(event);
        this.setState(state => ({
          pathInProgress: point ? state.pathInProgress.concat([point]) : state.pathInProgress
        }), () => this.processDrag());
      }
      
      mouseLeave(event) {
        this.mouseUp(event);
      }
            
      touchEnd(event) {
        this.mouseUp(event);
        event.preventDefault();
      }
      
      keyDown(event) {
        // console.log("DOWN", event.key);
        this.handleKeyDown(event.key);
      }
      
      keyUp(event) {
        // console.log("UP", event.key);
        this.handleKeyUp(event.key);
      }
      
      handleKeyDown(key) {
        if (key >= '0' && key <= '9') {
          this.setState({
            restrictedFiducialId: Number(key)
          });
        } else if (key == '-') {
          this.setState({
            restrictedFiducialId: null
          });
        } else {
          let send = false;
          let sendSpeed = false;
          this.setState(state => {
          switch(key) {
            case 'w':
              console.log('down w');
              send = true;
              return {
                forcedForward: 1 // (state.forcedForward || 0) + 1
              };
                    
            case 'a':
              console.log('down a');
              send = true;
              return {
                forcedTurn: -1 // state.forcedTurn - 1
              };
          
            case 's':
              console.log('down s');
              send = true;
              return {
                forcedForward: -1 // (state.forcedForward > 0 ? 0 : (state.forcedForward || 0) - 1)
              };
            
            case 'd':
              console.log('down d');
              send = true;
              return {
                forcedTurn: 1 //state.forcedTurn + 1
              };
            
            case ' ':
              console.log('down <space>');
              send = true;
              return {
                forcedForward: 0,
                forcedTurn: 0
              };
            
            // speed
            case '[':
              console.log('down [');
              sendSpeed = true;
              return {
                topSpeed: this.state.topSpeed / 1.25,
                slowKeyPressed: true
              }
              
            case ']':
              console.log('down ]');
              sendSpeed = true;
              let newSpeed = this.state.topSpeed * 1.25;
              return {
                topSpeed: newSpeed > 300 ? this.state.topSpeed : newSpeed,
                speedKeyPressed: true
              }
              
            // accel
            case '{':
              console.log('down {');
              sendSpeed = true;
              return {
                accel: this.state.accel / 1.25,
                decelKeyPressed: true
              }
              
            case '}':
              console.log('down }');
              sendSpeed = true;
              let newAccel = this.state.accel * 1.25;
              return {
                accel: newAccel > 300 ? this.state.accel : newAccel,
                accelKeyPressed: true
              }
            }
          }, () => {
            if (send) {
              this.sendForce();
            } else if (sendSpeed) {
              this.sendSpeed();
            }
          });
        }
        return false;
      }
      
      handleKeyUp(key) {
        let send = false;
        this.setState(state => {
          switch(key) {
          case 'w':
            console.log('up w');
            send = true;
            return {
              forcedForward: 0
            }
          case 'a':
            console.log('up a');
            send = true;
            return {
              forcedTurn: 0
            }
          case 's':
            console.log('up s');
            send = true;
            return {
              forcedForward: 0
            }
          case 'd':
            console.log('up d');
            send = true;
            return {
              forcedTurn: 0
            }
            
          // speed
          case '[':
            console.log('up [');
            return {
              slowKeyPressed: false
            }
          case ']':
            console.log('up ]');
            return {
              speedKeyPressed: false
            }              

          // accel
          case '{':
            console.log('up {');
            return {
              decelKeyPressed: false
            }
          case '}':
            console.log('up }');
            return {
              accelKeyPressed: false
            }                          
          }
        }, () => send && this.sendForce());
        return false;
      }
      
      checkAndSendForce() {
        if (this.state.forcedTurn || this.state.forcedForward) {
          this.sendForce();
        }
      }
      
      sendForce() {
        sendForce(
          this.state.restrictedFiducialId, 
          this.state.forcedForward, 
          this.state.forcedTurn, 
          this.state.topSpeed,
          this.state.accel);
      }

      sendSpeed() {
        sendSpeed(this.state.restrictedFiducialId, this.state.topSpeed, this.state.accel);
      }
	  
      processDrag() {        
        sendPath(this.state.candidate, this.state.pathInProgress, this.state.topSpeed, this.state.accel);
        this.setState({
          candidate: null,
          pathInProgress: null
        });
      }
      
      render() {
        return <div tabIndex="0"
            onKeyDown={this.keyDown.bind(this)}
            onKeyUp={this.keyUp.bind(this)} >
          <div className={"buttons" + (this.state.restrictedFiducialId ? " double" : "")}>
            <p className="info">
              Drag on the screen, starting from a chairbot, to request a path. <br /><br /><strong>{this.state.restrictedFiducialId ? `You control chairbot #${this.state.restrictedFiducialId}.` : "You can control any chairbot."}</strong><br /><br />
              Speed: <strong>{Math.round(this.state.topSpeed*10)/10}</strong><br />
              <KeyButton pressed={this.state.slowKeyPressed} handler={this} keyChar="[" />
              <KeyButton pressed={this.state.speedKeyPressed} handler={this} keyChar="]" />
              <br />
              Acceleration: <strong>{Math.round(this.state.accel*10)/10}</strong>
              <br />
              <KeyButton pressed={this.state.decelKeyPressed} handler={this} keyChar="{" />
              <KeyButton pressed={this.state.accelKeyPressed} handler={this} keyChar="}" />
            </p>
            {this.state.restrictedFiducialId ? <p className="keyGroup">
              Alternative key-based controls:<br /><br />
                <KeyButton pressed={this.state.forcedForward > 0} handler={this} keyChar="w" />
                <br />
                <KeyButton pressed={this.state.forcedTurn < 0} handler={this} keyChar="a" />
                <KeyButton pressed={this.state.forcedForward < 0} handler={this} keyChar="s" />
                <KeyButton pressed={this.state.forcedTurn > 0} handler={this} keyChar="d" />
                <br />
                <KeyButton pressed={false} handler={this} keyChar=" " text="space (stop!)" />
              </p> : ''}
          </div>
          <svg 
            id="drag-view" 
            viewBox="0 0 100 100" 
            preserveAspectRatio="none"
            ref={(ref) => this.svg = ref}
            onMouseDown={this.mouseDown.bind(this)}
            onTouchStart={this.touchStart.bind(this)}
            onMouseMove={this.mouseMove.bind(this)}
            onTouchMove={this.touchMove.bind(this)}
            onMouseUp={this.mouseUp.bind(this)}
            onMouseLeave={this.mouseLeave.bind(this)} 
            onTouchEnd={this.touchEnd.bind(this)}
            onTouchCancel={this.touchEnd.bind(this)} >
              {Object.keys(this.state.states).map(key =>
                <ChairBot status={this.state.states[key]} highlight={key == this.state.candidate} key={`chair-${key}`} isDraggable={this.state.restrictedFiducialId === null || key == this.state.restrictedFiducialId /* == intentional to allow type conversion */} />
              )}
              {this.state.pathInProgress ? <g stroke="#0a0"><PathView path={this.state.pathInProgress} /></g> : ''}
          </svg>
        </div>
      }
      
      componentDidMount() {
        // console.log("Drag View App mounted!");
        theViewer = this;
      }
      
      handleUpdate(status) {
        console.log("update!", status);
        let newStates = {};
        newStates[status.id] = status;
        this.setState((state) => ({
          states: Object.assign({}, state.states, newStates),
        }));
      }
    }
    $(function() {
      ReactDOM.render(<DragViewApp />, document.getElementById('root'));
    });
  </script>
</body>
