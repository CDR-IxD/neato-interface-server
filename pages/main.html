<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      font-family: "Helvetica Neue", sans-serif;
    }
    #camera-frame {
      position: absolute;
      margin: 0;
      padding: 0;
      top: 0;
      left: 0;
      height: 100%;
      width: 100%;
    }
    
    #root, #drag-view {
      position: absolute;
      margin: 0;
      padding: 0;
      top: 0;
      left: 0;
      height: 100%;
      width: 100%;
    }
        
    .buttons {
      z-index: 1000;
      width: 250px;
      text-align: center;
      position: absolute;
      top: 10;
      left: 0;
      background: rgba(255, 255, 255, 0.5);
      opacity: 1.0;
      padding: 0;
      border-radius: 0 0 20px 0;
    }
    
    .buttons.double {
      /* width: 500px; */
    }
    
    .double .info {
      width: 230px;
      display: inline-block;
      vertical-align: top;
    }
    
    .buttons button {
      width: 60px;
      height: 30px;
      
      background: blue;
      border: 0;
      border-radius: 8px;
      opacity: 1.0;
      color: white;
      margin: 2px;
    }
    .buttons button:active, .buttons button.active {
      background: #abcdef;
    }
    
    svg text::selection {
      background: none;
    }
        
    iframe {
      border: 0;
    }
    
    .double .keyGroup {
      display: inline-block;
      width: 230px;
      vertical-align: top;
    }
  </style>
  <title>Path control</title>
  
  <script src="react.development.js"></script>
  <script src="react-dom.development.js"></script>
  <script src="babel.min.js"></script>
  <script src="jquery-3.2.1.js"></script>
  </head>
<body>
  <iframe id="camera-frame"></iframe>
  <script type="text/javascript">
    var camera = document.getElementById('camera-frame');
    camera.src = "/view-stream.html"
  </script>
  <div id="root"><!-- react root --></div>
  
  <script type="text/babel">
    var restrictedFiducialId = window.location.hash.startsWith('#') ? Number(window.location.hash.substr(1)) : null;
    var socket;
    
    function connectNewSocket() {
      socket = new WebSocket("ws://"+document.location.host+"/web-controller");
      socket.onmessage = function(event) {
        let data = JSON.parse(event.data);
        data.bots.forEach(handleUpdate);
      }
      socket.onopen = function(event) {
        socket.onclose = function() {
          setTimeout(connectNewSocket, 500);
        }
      }
    }
    $(connectNewSocket);
    
    function pathId() {
      return ""+Math.round(Math.random()*1e7);
    }
    
    function sendPath(fiducialKey, path, topSpeed, accel) {
      console.log("requesting path", fiducialKey, path);
      let pid = pathId();
      socket.send(JSON.stringify({
        action: "requestPath",
        bot: fiducialKey,
        pathId: pid,
        path: path,
        topSpeed: topSpeed,
        accel: accel
      }));
    }
    
    function sendForce(fiducialKey, forcedForward, forcedTurn, topSpeed, accel) {
      console.log("requesting force", fiducialKey, forcedForward, forcedTurn);
      socket.send(JSON.stringify({
        action: "requestForced",
        bot: fiducialKey,
        forward: forcedForward,
        turn: forcedTurn,
        topSpeed: topSpeed,
        accel: accel
      }));
    }
    
    function sendSpeed(fiducialKey, topSpeed, accel) {
      console.log("updating speed", fiducialKey, topSpeed, accel);
      socket.send(JSON.stringify({
        action: "requestSpeed",
        bot: fiducialKey,
        topSpeed: topSpeed,
        accel: accel
      }));
    }
    
    var theViewer;
    function handleUpdate(update) {
      if (theViewer) {
        theViewer.handleUpdate(update);
      }
    }
    
    function centerOf(pts) {
      return pts.reduce((p, c, _, {length: n}) => ({x: p.x+c.x/n, y: p.y+c.y/n}), {x: 0, y: 0}); // average of points
    }
    
    function distance(p1, p2) {
      return p1 == null || p2 == null ? Number.POSITIVE_INFINITY : Math.sqrt(Math.pow(p2.x-p1.x, 2) + Math.pow(p2.y-p1.y, 2));
    }
    
    function scale(pt, scale) {
      return pt ? {x: scale*pt.x, y: scale*pt.y} : {x: 0, y: 0};
    }

    class ChairBot extends React.Component {
      location() {
        return this.props.status.location.map(pt => scale(pt, 100));
      }
      
      centerPt() {
        return centerOf(this.location());
      }
      
      chair() {
        let loc = this.location();
        // console.log("path from", loc);
        let [p1, p2, p3, p4] = loc;
        let cpt = centerOf(loc);
        let dir = centerOf([p1, p2]);
        
        return `M${p1.x},${p1.y}L${p2.x},${p2.y}L${p3.x},${p3.y}L${p4.x},${p4.y}Z M${cpt.x},${cpt.y}L${dir.x},${dir.y}`;
      }
      
      path() {
        let points = (this.props.status.path || []).map(pt => scale(pt, 100));
        if (points.length > 0) {
          return "M" + points.map(({x, y}) => `${x},${y}`).join("L")
        } else {
          return "";
        }
      }
      
      render() {
        if (! this.props.status.location) {
          return null;
        }
        let cpt = this.centerPt();
        return <g>
          <path d={this.chair()} strokeWidth="1" stroke={this.props.isDraggable ? "#0a0" : "#000"} fill="none" strokeLinejoin="round"/>
          {this.props.status.path ? <path d={this.path()} strokeWidth="1" stroke="#a00" fill="none" /> : ""}
          <circle cx={cpt.x} cy={cpt.y} r="3" fill="#fff" opacity="0.5"/>
          <text x={cpt.x-1.5} y={cpt.y+1.5} fontFamily="Verdana" fontSize="5" fill="#000">{this.props.status.id}</text>
        </g>
      }
    }
    
    class PathView extends React.Component {
      path() {
        let loc = this.props.path.map(pt => scale(pt, 100));
        return `M${loc.map(pt => `${pt.x},${pt.y}`).join('L')}`;
      }
      
      render() {
        return <path d={this.path()} strokeWidth="1" fill="none" />
      }
    }

    class KeyButton extends React.Component {
      render() {
        let props = this.props;
        let handler = props.handler;
        let key = this.props.keyChar;
        let text = this.props.text || key;
        return <button
                className={props.pressed ? "active" : ""}
                onMouseDown={() => handler.handleKeyDown(key)}
                onTouchStart={(event) => { handler.handleKeyDown(key); event.preventDefault(); }}
                onMouseUp={() => handler.handleKeyUp(key)}
                onMouseLeave={() => handler.handleKeyUp(key)}
                onTouchCancel={() => handler.handleKeyUp(key)}
                onTouchEnd={() => handler.handleKeyUp(key)} >
            {text}
          </button>
        
      }
    }
    
    function pt(r, a) {
      let rad = a*Math.PI/180;
      return `${-r*Math.sin(rad)} ${-r*Math.cos(rad)}`;
    }
    function map(value, imin, imax, omin, omax) {
      return (value-imin) / (imax-imin) * (omax-omin) + omin;
    }
    function sigfig(v, n) {
      let factor = Math.pow(10, n);
      return Math.round(v * factor) / factor;
    }
    
    class ForceDragTarget extends React.Component {
      constructor(props) {
        super(props);
        this.deadZones = 40; // degrees spanning straight up/down
        this.angleZones = 160;
        this.innerRadius = 40;
        this.outerRadius = 10;
      }
      
      mousePosition(event) {
        if (! ('pageX' in event) && ! (event.nativeEvent.touches.length > 0)) {
          return null;
        }
        let bounds = ReactDOM.findDOMNode(this.svg).getBoundingClientRect();
        console.log(bounds);
        return {
          x: ('pageX' in event ? event.pageX - bounds.x : event.nativeEvent.touches[0].pageX - bounds.x) / bounds.width, 
          y: ('pageY' in event ? event.pageY - bounds.y : event.nativeEvent.touches[0].pageY - bounds.y) / bounds.height
        }
      }
      
      updateCommand(event) {
        let {deadZones, angleZones} = this;
        let bounds = ReactDOM.findDOMNode(this.svg).getBoundingClientRect();
        let pos = this.mousePosition(event);
        if (pos) {
          console.log("Force Drag at", pos);
          // let d = distance(pos, {x: 0.5, y: 0.5});
          var speed = Math.max(Math.min((-pos.y + 0.5) / (this.innerRadius/bounds.height), 1), -1);
          var turn = 0;
          
          let ang = (Math.atan2(pos.y-0.5, pos.x-0.5) * 180/Math.PI + 90);
          if (ang > 180) {
            ang = ang-360;
          }
          console.log("angle is", ang);
          if (ang > this.deadZones/2 && ang < this.angleZones/2) {
            turn = map(ang, this.deadZones/2, this.angleZones/2, 0, 1);
          } else if (ang > 180-this.angleZones/2 && ang < 180-this.deadZones/2) {
            turn = map(ang, 180-this.deadZones/2, 180-this.angleZones/2, 0, 1);
          } else if (ang < -this.deadZones/2 && ang > -this.angleZones/2) {
            turn = map(ang, -this.deadZones/2, -this.angleZones/2, 0, -1);
          } else if (ang < -180+this.angleZones/2 && ang > -180+this.deadZones/2) {
            turn = map(ang, -180+this.deadZones/2, -180+this.angleZones/2, 0, -1);
          }
          
          this.props.update(speed, turn);
        }
      }
      
      mouseDown(event) {
        this.isDown = true;
        this.updateCommand(event);
      }
      touchStart(event) {
        this.mouseDown(event);
        event.preventDefault();
      }
      mouseMove(event) {
        if (this.isDown) {
          this.updateCommand(event);
        }
      }
      touchMove(event) {
        this.mouseMove(event);
        event.preventDefault();        
      }
      mouseUp(event) {
        this.isDown = false;
        this.props.update(0, 0);
      }
      mouseLeave(event) {
        if (this.isDown) {
          this.mouseUp(event);
        }
      }
      touchEnd(event) {
        this.mouseUp(event);
        event.preventDefault();
      }
      
      render() {
        let {deadZones, innerRadius, outerRadius, angleZones} = this;
        let r = innerRadius + outerRadius;
        let ir = innerRadius;
        
        let segments = <g>
          <path d={`M 0 0 L${pt(r, -deadZones/2)} A${r} ${r} 0 0 0 ${pt(r, deadZones/2)} z`} fill="darkgreen" stroke="white" strokeWidth="2"/>
          <path d={`M 0 0 L${pt(r, 180-deadZones/2)} A${r} ${r} 0 0 0 ${pt(r, 180+deadZones/2)} z`} fill="darkred" stroke="white" strokeWidth="2"/>
          <path d={`M 0 0 L${pt(r, deadZones/2)} A${r} ${r} 0 0 0 ${pt(r, angleZones/2)} z`} fill="blue" stroke="white" strokeWidth="2"/>
          <path d={`M 0 0 L${pt(r, 180-angleZones/2)} A${r} ${r} 0 0 0 ${pt(r, 180-deadZones/2)} z`} fill="blue" stroke="white" strokeWidth="2"/>
          <path d={`M 0 0 L${pt(r, -angleZones/2)} A${r} ${r} 0 0 0 ${pt(r, -deadZones/2)} z`} fill="blue" stroke="white" strokeWidth="2"/>
          <path d={`M 0 0 L${pt(r, -180+deadZones/2)} A${r} ${r} 0 0 0 ${pt(r, -180+angleZones/2)} z`} fill="blue" stroke="white" strokeWidth="2"/>



          <path d={`M 0 0 L${pt(ir, -deadZones/2)} A${r} ${r} 0 0 0 ${pt(ir, deadZones/2)} z`} fill="green" stroke="white" strokeWidth="2"/>
          <path d={`M 0 0 L${pt(ir, 180-deadZones/2)} A${r} ${r} 0 0 0 ${pt(ir, 180+deadZones/2)} z`} fill="red" stroke="white" strokeWidth="2"/>
          <path d={`M 0 0 L${pt(ir, deadZones/2)} A${r} ${r} 0 0 0 ${pt(ir, angleZones/2)} z`} fill="#55f" stroke="white" strokeWidth="2"/>
          <path d={`M 0 0 L${pt(ir, 180-angleZones/2)} A${r} ${r} 0 0 0 ${pt(ir, 180-deadZones/2)} z`} fill="#55f" stroke="white" strokeWidth="2"/>
          <path d={`M 0 0 L${pt(ir, -angleZones/2)} A${r} ${r} 0 0 0 ${pt(ir, -deadZones/2)} z`} fill="#55f" stroke="white" strokeWidth="2"/>
          <path d={`M 0 0 L${pt(ir, -180+deadZones/2)} A${r} ${r} 0 0 0 ${pt(ir, -180+angleZones/2)} z`} fill="#55f" stroke="white" strokeWidth="2"/>

        </g>
        
        
        return <div>
          <svg 
              id="drag-target-view" 
              style={{width: 2*(innerRadius+outerRadius+2), height: 2*(innerRadius+outerRadius+2)}}
              viewBox={`${-(innerRadius+outerRadius+2)} ${-(innerRadius+outerRadius+2)} ${2*(innerRadius+outerRadius+2)} ${2*(innerRadius+outerRadius+2)}`}
              preserveAspectRatio="none"
              ref={(ref) => this.svg = ref}
              onMouseDown=  {this.mouseDown .bind(this)}
              onTouchStart= {this.touchStart.bind(this)}
              onMouseMove=  {this.mouseMove .bind(this)}
              onTouchMove=  {this.touchMove .bind(this)}
              onMouseUp=    {this.mouseUp   .bind(this)}
              onMouseLeave= {this.mouseLeave.bind(this)} 
              onTouchEnd=   {this.touchEnd  .bind(this)}
              onTouchCancel={this.touchEnd  .bind(this)} >
            {segments}
          </svg>
          <p>Speed: {sigfig(this.props.forcedForward, 2)} — Turn: {sigfig(this.props.forcedTurn, 2)}</p>
        </div>
      }
    }
    
    class SliderToggle extends React.Component {
      mouseDown() {
        this.props.toggle();
      }
      
      render() {
        let toggleStyle = {
          width: this.props.width || 50,
          height: this.props.height || 20,
          borderRadius: (this.props.height || 20) / 3,
          boxShadow: "inset 0 0 10px #000000",
          position: "relative",
          display: "inline-block",
          top: 4,
          margin: "0px 5px"
        }
        let sliderStyle = {
          width: toggleStyle.width / 2.1,
          height: toggleStyle.height * 0.9,
          background: "green",
          borderRadius: toggleStyle.borderRadius,
          boxShadow: "inset 0 0 5px darkgreen",
          position: "absolute",
          left: this.props.toggled ? toggleStyle.width - (toggleStyle.width/2.1) - toggleStyle.height * 0.05 : toggleStyle.height * 0.05,
          top: toggleStyle.height * 0.05,
          transition: "left 0.25s ease-in-out 0"
        }
        return <span style={toggleStyle} onMouseDown={() => this.mouseDown()} onTouchStart={(event) => {this.mouseDown(); event.preventDefault();}}>
            <span style={sliderStyle} />
          </span>
      }
    }

    class DragViewApp extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          states: {},
          restrictedFiducialId: restrictedFiducialId,
          forcedForward: 0,
          forcedTurn: 0,
          topSpeed: 50,
          accel: 300,
          analogControls: true
        }
        
        this.forcedTimer = setInterval(() => this.checkAndSendForce(), 250);
      }
      
      fiducialCenter(key) {
        let loc = this.state.states[key];
        return loc && centerOf(loc.location);
      }

      mousePosition(event) {
        if (! ('pageX' in event) && ! (event.nativeEvent.touches.length > 0)) {
          return null;
        }
        let bounds = ReactDOM.findDOMNode(this.svg).getBoundingClientRect();
        return {
          x: ('pageX' in event ? event.pageX : event.nativeEvent.touches[0].pageX) / bounds.width, 
          y: ('pageY' in event ? event.pageY : event.nativeEvent.touches[0].pageY) / bounds.height
        }
      }
      
      nearestFiducial(point) {
        let keys = Object.keys(this.state.states)
        if (this.state.restrictedFiducialId !== null) {
          keys = keys.filter(k => k == this.state.restrictedFiducialId);
        }
        return keys.reduce((p, k) => {
          if (distance(this.fiducialCenter(k), point) < distance(this.fiducialCenter(p), point)) {
            return k;
          } else {
            return p;
          }
        }, null);
      }
      
      isSvgEvent(event) {
        return event.target === this.svg;
      }
      
      mouseDown(event) {
        // if (! this.isSvgEvent(event)) { return; }
        this.dragging = true;
        let point = this.mousePosition(event);
        let candidate = this.nearestFiducial(point);
        console.log("mouse down with candidate", candidate);
        this.setState({
          candidate: candidate,
          pathInProgress: [this.fiducialCenter(candidate), point]
        });
      }
      
      touchStart(event) {
        this.mouseDown(event);
        event.preventDefault();
      }
      
      mouseMove(event) {
        // if (! this.isSvgEvent(event)) { return; }
        if (! this.dragging) { return; }
        let point = this.mousePosition(event);
        this.setState(state => ({
          pathInProgress: state.pathInProgress.concat([point])
        }));
      }
      
      touchMove(event) {
        this.mouseMove(event);
        event.preventDefault();
      }

      mouseUp(event) {
        // if (! this.isSvgEvent(event)) { return; }
        if (! this.dragging) { return; }
        this.dragging = false;
        let point = this.mousePosition(event);
        this.setState(state => ({
          pathInProgress: point ? state.pathInProgress.concat([point]) : state.pathInProgress
        }), () => this.processDrag());
      }
      
      mouseLeave(event) {
        this.mouseUp(event);
      }
            
      touchEnd(event) {
        this.mouseUp(event);
        event.preventDefault();
      }
      
      keyDown(event) {
        // console.log("DOWN", event.key);
        this.handleKeyDown(event.key);
      }
      
      keyUp(event) {
        // console.log("UP", event.key);
        this.handleKeyUp(event.key);
      }
      
      setForced(forward, turn) {
        this.setState({
          forcedForward: forward,
          forcedTurn: turn
        }, () => this.sendForce());
      }
      
      handleKeyDown(key) {
        if (key >= '0' && key <= '9') {
          this.setState({
            restrictedFiducialId: Number(key)
          });
        } else if (key == '-') {
          this.setState({
            restrictedFiducialId: null
          });
        } else {
          let send = false;
          let sendSpeed = false;
          this.setState(state => {
          switch(key) {
            case 'w':
              console.log('down w');
              send = true;
              return {
                forcedForward: 1 // (state.forcedForward || 0) + 1
              };
                    
            case 'a':
              console.log('down a');
              send = true;
              return {
                forcedTurn: -1 // state.forcedTurn - 1
              };
          
            case 's':
              console.log('down s');
              send = true;
              return {
                forcedForward: -1 // (state.forcedForward > 0 ? 0 : (state.forcedForward || 0) - 1)
              };
            
            case 'd':
              console.log('down d');
              send = true;
              return {
                forcedTurn: 1 //state.forcedTurn + 1
              };
            
            case ' ':
              console.log('down <space>');
              send = true;
              return {
                forcedForward: 0,
                forcedTurn: 0
              };
            
            // speed
            case '[':
              console.log('down [');
              sendSpeed = true;
              return {
                topSpeed: this.state.topSpeed / 1.25,
                slowKeyPressed: true
              }
              
            case ']':
              console.log('down ]');
              sendSpeed = true;
              let newSpeed = this.state.topSpeed * 1.25;
              return {
                topSpeed: newSpeed > 300 ? this.state.topSpeed : newSpeed,
                speedKeyPressed: true
              }
              
            // accel
            case '{':
              console.log('down {');
              sendSpeed = true;
              return {
                accel: this.state.accel / 1.25,
                decelKeyPressed: true
              }
              
            case '}':
              console.log('down }');
              sendSpeed = true;
              let newAccel = this.state.accel * 1.25;
              return {
                accel: newAccel > 300 ? this.state.accel : newAccel,
                accelKeyPressed: true
              }
            }
          }, () => {
            if (send) {
              this.sendForce();
            } else if (sendSpeed) {
              this.sendSpeed();
            }
          });
        }
        return false;
      }
      
      handleKeyUp(key) {
        let send = false;
        this.setState(state => {
          switch(key) {
          case 'w':
            console.log('up w');
            send = true;
            return {
              forcedForward: 0
            }
          case 'a':
            console.log('up a');
            send = true;
            return {
              forcedTurn: 0
            }
          case 's':
            console.log('up s');
            send = true;
            return {
              forcedForward: 0
            }
          case 'd':
            console.log('up d');
            send = true;
            return {
              forcedTurn: 0
            }
            
          // speed
          case '[':
            console.log('up [');
            return {
              slowKeyPressed: false
            }
          case ']':
            console.log('up ]');
            return {
              speedKeyPressed: false
            }              

          // accel
          case '{':
            console.log('up {');
            return {
              decelKeyPressed: false
            }
          case '}':
            console.log('up }');
            return {
              accelKeyPressed: false
            }                          
          }
        }, () => send && this.sendForce());
        return false;
      }
      
      checkAndSendForce() {
        if (this.state.forcedTurn || this.state.forcedForward) {
          this.sendForce();
        }
      }
      
      sendForce() {
        sendForce(
          this.state.restrictedFiducialId, 
          this.state.forcedForward, 
          this.state.forcedTurn, 
          this.state.topSpeed,
          this.state.accel);
      }

      sendSpeed() {
        sendSpeed(this.state.restrictedFiducialId, this.state.topSpeed, this.state.accel);
      }
	  
      processDrag() {        
        sendPath(this.state.candidate, this.state.pathInProgress, this.state.topSpeed, this.state.accel);
        this.setState({
          candidate: null,
          pathInProgress: null
        });
      }
      
      render() {
        return <div tabIndex="0"
            onKeyDown={this.keyDown.bind(this)}
            onKeyUp={this.keyUp.bind(this)} >
          <div className={"buttons" + (this.state.restrictedFiducialId ? " double" : "")}>
            <p className="info">
              Drag on the screen, starting from a chairbot, to request a path. <br /><br /><strong>{this.state.restrictedFiducialId ? `You control chairbot #${this.state.restrictedFiducialId}.` : "You can control any chairbot."}</strong><br /><br />
              Speed: <strong>{Math.round(this.state.topSpeed*10)/10}</strong><br />
              <KeyButton pressed={this.state.slowKeyPressed} handler={this} keyChar="[" />
              <KeyButton pressed={this.state.speedKeyPressed} handler={this} keyChar="]" />
              <br />
              Acceleration: <strong>{Math.round(this.state.accel*10)/10}</strong>
              <br />
              <KeyButton pressed={this.state.decelKeyPressed} handler={this} keyChar="{" />
              <KeyButton pressed={this.state.accelKeyPressed} handler={this} keyChar="}" />
            </p>
            {this.state.restrictedFiducialId ? <div className="keyGroup">
              <p><strong>Alternative Controls</strong><br />
                Digital 
                <SliderToggle 
                  toggle={() => this.setState(state => {return {analogControls: ! state.analogControls}; })}
                  toggled={this.state.analogControls} /> 
                Analog<br />
              </p>
                {this.state.analogControls ? 
                  <ForceDragTarget forcedForward={this.state.forcedForward} forcedTurn={this.state.forcedTurn} update={this.setForced.bind(this)}/> :
                  [ <KeyButton pressed={this.state.forcedForward > 0} handler={this} keyChar="w" />,
                    <br />,
                    <KeyButton pressed={this.state.forcedTurn < 0} handler={this} keyChar="a" />,
                    <KeyButton pressed={this.state.forcedForward < 0} handler={this} keyChar="s" />,
                    <KeyButton pressed={this.state.forcedTurn > 0} handler={this} keyChar="d" />,
                    <br />,
                    <KeyButton pressed={false} handler={this} keyChar=" " text="space (stop!)" />
                  ]
                }
            </div> : ''}
          </div>
          <svg 
            id="drag-view" 
            viewBox="0 0 100 100" 
            preserveAspectRatio="none"
            ref={(ref) => this.svg = ref}
            onMouseDown={this.mouseDown.bind(this)}
            onTouchStart={this.touchStart.bind(this)}
            onMouseMove={this.mouseMove.bind(this)}
            onTouchMove={this.touchMove.bind(this)}
            onMouseUp={this.mouseUp.bind(this)}
            onMouseLeave={this.mouseLeave.bind(this)} 
            onTouchEnd={this.touchEnd.bind(this)}
            onTouchCancel={this.touchEnd.bind(this)} >
              {Object.keys(this.state.states).map(key =>
                <ChairBot status={this.state.states[key]} highlight={key == this.state.candidate} key={`chair-${key}`} isDraggable={this.state.restrictedFiducialId === null || key == this.state.restrictedFiducialId /* == intentional to allow type conversion */} />
              )}
              {this.state.pathInProgress ? <g stroke="#0a0"><PathView path={this.state.pathInProgress} /></g> : ''}
          </svg>
        </div>
      }
      
      componentDidMount() {
        // console.log("Drag View App mounted!");
        theViewer = this;
      }
      
      handleUpdate(status) {
        console.log("update!", status);
        let newStates = {};
        newStates[status.id] = status;
        this.setState((state) => ({
          states: Object.assign({}, state.states, newStates),
        }));
      }
    }
    $(function() {
      ReactDOM.render(<DragViewApp />, document.getElementById('root'));
    });
  </script>
</body>
